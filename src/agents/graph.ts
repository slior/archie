import { StateGraph, END, START, MemorySaver } from "@langchain/langgraph";
import { RunnableConfig } from "@langchain/core/runnables";
import { echoAgentNode } from "./EchoAgentNode";
import { analysisPrepareNode } from "./AnalysisPrepareNode";
import { analysisInterruptNode } from "./AnalysisInterruptNode";
import { documentRetrievalNode } from "./DocumentRetrievalNode";
import { contextBuildingAgentNode } from './ContextBuildingAgentNode';
import { AppRunnableConfig, dbg } from "../utils";

// Define node names as constants
export const ECHO_AGENT = "echoAgent";
export const ANALYSIS_PREPARE = "analysisPrepare";
export const ANALYSIS_INTERRUPT = "analysisInterrupt";
export const DOCUMENT_RETRIEVAL = "documentRetrievalNode";
export const CONTEXT_BUILDING_AGENT = "contextBuildingAgent";

/**
 * Represents the role of a participant in a conversation.
 * - 'user': Represents messages/inputs from the human user
 * - 'agent': Represents responses from the AI agent
 */
export type Role = 'user' | 'agent';

export const ANALYZE_FLOW = 'analyze';
export const BUILD_CONTEXT_FLOW = 'build_context';
export type Flow = typeof ANALYZE_FLOW | typeof BUILD_CONTEXT_FLOW; 

const CMD_ECHO = "echo";

/**
 * Represents the core application state that flows through the agent graph.
 * This state is passed between nodes and updated during graph execution.
 */
export interface AppState {
    /** The raw input text provided by the user */
    userInput: string;

    /** The latest response generated by an agent node */
    response: string;

    /** Map of file paths to their contents for code analysis */
    fileContents: Record<string, string>;

    /** Map of input file names to their contents, populated by DocumentRetrievalNode */
    inputs: Record<string, string>;

    /** The path to the directory from which to load input files */
    inputDirectoryPath: string;

    /** Conversation history between user and agent during analysis */
    analysisHistory: Array<{ role: Role; content: string }>;

    /** The final analysis output generated by the analysis agent */
    analysisOutput: string;

    /** The current question being asked by the agent during an analysis interrupt */
    currentAnalysisQuery: string;

    /** The name/ID of the LLM model to use for agent interactions */
    modelName: string;

    // New fields for Context Building Flow
    currentFlow?: Flow | null;
    systemName?: string;
    contextBuilderOutputContent?: string;
    contextBuilderOutputFileName?: string;
}

function shouldTriggerAnalysis(state: AppState): boolean {
    return state.currentFlow === ANALYZE_FLOW;
}

function shouldTriggerContextBuilding(state: AppState): boolean {
    return state.currentFlow === BUILD_CONTEXT_FLOW;
}

// Define the channels for the graph state, specifying how they should be updated.
const channels = {
    userInput: { value: (x: string, y: string) => y ?? x, default: () => "" },
    inputDirectoryPath: { value: (x: string, y: string) => y ?? x, default: () => "" },
    inputs: { value: (x: Record<string, string>, y: Record<string, string>) => y ?? x, default: () => ({}) },
    response: { value: (x: string, y: string) => y ?? x, default: () => "" },
    fileContents: { value: (x: Record<string, string>, y: Record<string, string>) => y ?? x, default: () => ({}) },
    analysisHistory: { value: (x: Array<{ role: Role; content: string }>, y: Array<{ role: Role; content: string }>) => (x || []).concat(y || []), default: () => [] as Array<{ role: Role; content: string }> },
    analysisOutput: { value: (x: string, y: string) => y ?? x, default: () => "" },
    currentAnalysisQuery: { value: (x: string, y: string) => y ?? x, default: () => "" },
    modelName: { value: (x: string, y: string) => y ?? x, default: () => "" },

    // New channel configurations
    currentFlow: { value: (x: Flow | null | undefined, y: Flow | null | undefined) => y !== undefined ? y : x, default: () => null },
    systemName: { value: (x: string | undefined, y: string | undefined) => y !== undefined ? y : x, default: () => undefined },
    contextBuilderOutputContent: { value: (x: string | undefined, y: string | undefined) => y !== undefined ? y : x, default: () => undefined },
    contextBuilderOutputFileName: { value: (x: string | undefined, y: string | undefined) => y !== undefined ? y : x, default: () => undefined },
};

type StateGraphNode = (state: AppState, config: RunnableConfig) => Promise<Partial<AppState>>;

export function safeAppConfig(config: RunnableConfig): AppRunnableConfig {
    if (!config.configurable) {
        throw new Error("configurable property is required");
    }
    return config as AppRunnableConfig;
}

export function createWorkflow(nodes: Record<string, StateGraphNode>)
{
       return new StateGraph<AppState>({ channels })
        .addNode(ECHO_AGENT, nodes[ECHO_AGENT])
        .addNode(ANALYSIS_PREPARE, nodes[ANALYSIS_PREPARE])
        .addNode(ANALYSIS_INTERRUPT, nodes[ANALYSIS_INTERRUPT])
        .addNode(DOCUMENT_RETRIEVAL, nodes[DOCUMENT_RETRIEVAL])
        .addNode(CONTEXT_BUILDING_AGENT, nodes[CONTEXT_BUILDING_AGENT])
        
        // Make the conditional edge originate from START
        .addConditionalEdges(START, 
            (state: AppState) => { // Keep synchronous
                
                const userInput = state.userInput.toLowerCase();
                let nextNodeDecision: string;

                if (shouldTriggerAnalysis(state)) {
                    nextNodeDecision = DOCUMENT_RETRIEVAL;
                }
                else if (shouldTriggerContextBuilding(state)) {
                    nextNodeDecision = DOCUMENT_RETRIEVAL;
                } else if (userInput.startsWith(CMD_ECHO)) {
                    nextNodeDecision = ECHO_AGENT;
                } else {
                    nextNodeDecision = END;
                }
                
                dbg(`Initial Routing from START: Routing to ${nextNodeDecision}`);
                return nextNodeDecision;
            },
            {
                // Mapping destinations
                [ECHO_AGENT]: ECHO_AGENT,
                [DOCUMENT_RETRIEVAL]: DOCUMENT_RETRIEVAL,
                [END]: END,
            }
        )
        .addConditionalEdges(DOCUMENT_RETRIEVAL, 
            (state: AppState) => {
                switch (state.currentFlow) {
                    case ANALYZE_FLOW:
                        dbg('Routing after Document Retrieval to Analysis Prepare');
                        return ANALYSIS_PREPARE;
                    case BUILD_CONTEXT_FLOW:
                        dbg('Routing after Document Retrieval to Context Building Agent');
                        return CONTEXT_BUILDING_AGENT;
                    default:
                        console.warn("Unknown flow in routeAfterDocumentRetrieval:", state.currentFlow);
                        dbg('Routing after Document Retrieval to END due to unknown flow.');
                        return END; // Default to END if flow is not set or unknown
                }
            },
            {
                [ANALYSIS_PREPARE]: ANALYSIS_PREPARE,
                [CONTEXT_BUILDING_AGENT]: CONTEXT_BUILDING_AGENT,
                [END]: END
            }
        )
        .addEdge(CONTEXT_BUILDING_AGENT, END)
        .addEdge(ECHO_AGENT, END)
        .addConditionalEdges(ANALYSIS_PREPARE,
            (state: AppState) => { // Keep synchronous 
                if (state.analysisOutput) {
                    return END;
                } else {
                    return ANALYSIS_INTERRUPT;
                }
            },
            {
                [END]: END,
                [ANALYSIS_INTERRUPT]: ANALYSIS_INTERRUPT
            }
        )
        .addEdge(ANALYSIS_INTERRUPT, ANALYSIS_PREPARE) // After interrupt node, go back to the PREPARE node to process the resumed input
    ;
    
}
// Instantiate the graph with the defined state and channels.
// const workflow = new StateGraph<AppState>({ channels })
//     .addNode(ECHO_AGENT, echoAgentNode as StateGraphNode)
//     .addNode(ANALYSIS_PREPARE, analysisPrepareNode as StateGraphNode)
//     .addNode(ANALYSIS_INTERRUPT, analysisInterruptNode as StateGraphNode)
//     .addNode(DOCUMENT_RETRIEVAL, documentRetrievalNode as StateGraphNode)
//     .addNode(CONTEXT_BUILDING_AGENT, contextBuildingAgentNode as StateGraphNode)
    
//     // Make the conditional edge originate from START
//     .addConditionalEdges(START, 
//         (state: AppState) => { // Keep synchronous
            
//             const userInput = state.userInput.toLowerCase();
//             let nextNodeDecision: string;

//             if (shouldTriggerAnalysis(state)) {
//                 nextNodeDecision = DOCUMENT_RETRIEVAL;
//             }
//             else if (shouldTriggerContextBuilding(state)) {
//                 nextNodeDecision = DOCUMENT_RETRIEVAL;
//             } else if (userInput.startsWith(CMD_ECHO)) {
//                 nextNodeDecision = ECHO_AGENT;
//             } else {
//                 nextNodeDecision = END;
//             }
            
//             dbg(`Initial Routing from START: Routing to ${nextNodeDecision}`);
//             return nextNodeDecision;
//         },
//         {
//             // Mapping destinations
//             [ECHO_AGENT]: ECHO_AGENT,
//             [DOCUMENT_RETRIEVAL]: DOCUMENT_RETRIEVAL,
//             [END]: END,
//         }
//     )
//     .addConditionalEdges(DOCUMENT_RETRIEVAL, 
//         (state: AppState) => {
//             switch (state.currentFlow) {
//                 case ANALYZE_FLOW:
//                     dbg('Routing after Document Retrieval to Analysis Prepare');
//                     return ANALYSIS_PREPARE;
//                 case BUILD_CONTEXT_FLOW:
//                     dbg('Routing after Document Retrieval to Context Building Agent');
//                     return CONTEXT_BUILDING_AGENT;
//                 default:
//                     console.warn("Unknown flow in routeAfterDocumentRetrieval:", state.currentFlow);
//                     dbg('Routing after Document Retrieval to END due to unknown flow.');
//                     return END; // Default to END if flow is not set or unknown
//             }
//         },
//         {
//             [ANALYSIS_PREPARE]: ANALYSIS_PREPARE,
//             [CONTEXT_BUILDING_AGENT]: CONTEXT_BUILDING_AGENT,
//             [END]: END
//         }
//     )
//     .addEdge(CONTEXT_BUILDING_AGENT, END)
//     .addEdge(ECHO_AGENT, END)
//     .addConditionalEdges(ANALYSIS_PREPARE,
//         (state: AppState) => { // Keep synchronous 
//             if (state.analysisOutput) {
//                 return END;
//             } else {
//                 return ANALYSIS_INTERRUPT;
//             }
//         },
//         {
//             [END]: END,
//             [ANALYSIS_INTERRUPT]: ANALYSIS_INTERRUPT
//         }
//     )
//     .addEdge(ANALYSIS_INTERRUPT, ANALYSIS_PREPARE) // After interrupt node, go back to the PREPARE node to process the resumed input
// ;

const nodes = {
    [ECHO_AGENT]: echoAgentNode as StateGraphNode,
    [ANALYSIS_PREPARE]: analysisPrepareNode as StateGraphNode,
    [ANALYSIS_INTERRUPT]: analysisInterruptNode as StateGraphNode,
    [DOCUMENT_RETRIEVAL]: documentRetrievalNode as StateGraphNode,
    [CONTEXT_BUILDING_AGENT]: contextBuildingAgentNode as StateGraphNode,
}
const workflow = createWorkflow(nodes);
const checkpointer = new MemorySaver();
export const app = workflow.compile({ checkpointer }); 