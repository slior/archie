import { StateGraph, END, START, MemorySaver } from "@langchain/langgraph";
import { RunnableConfig, Runnable } from "@langchain/core/runnables";
import { echoAgentNode } from "./EchoAgentNode";
import { analysisPrepareNode } from "./AnalysisPrepareNode";
import { analysisInterruptNode } from "./AnalysisInterruptNode";
import { documentRetrievalNode } from "./DocumentRetrievalNode";
import { contextBuildingAgentNode } from './ContextBuildingAgentNode';
import { AppRunnableConfig, dbg } from "../utils";
import { MemoryState } from "../memory/memory_types";

// Define node names as constants
export const ECHO_AGENT = "echoAgent";
export const ANALYSIS_PREPARE = "analysisPrepare";
export const ANALYSIS_INTERRUPT = "analysisInterrupt";
export const DOCUMENT_RETRIEVAL = "documentRetrievalNode";
export const CONTEXT_BUILDING_AGENT = "contextBuildingAgent";

/**
 * Represents the role of a participant in a conversation.
 * - 'user': Represents messages/inputs from the human user
 * - 'agent': Represents responses from the AI agent
 */
export type Role = 'user' | 'agent';

export const ANALYZE_FLOW = 'analyze';
export const BUILD_CONTEXT_FLOW = 'build_context';
export type Flow = typeof ANALYZE_FLOW | typeof BUILD_CONTEXT_FLOW; 

const CMD_ECHO = "echo";

/**
 * Represents the core application state that flows through the agent graph.
 * This state is passed between nodes and updated during graph execution.
 */
export interface AppState {
    /** The raw input text provided by the user */
    userInput: string;

    /** The latest response generated by an agent node */
    response: string;

    /** Map of file paths to their contents for code analysis */
    fileContents: Record<string, string>;

    /** Map of input file names to their contents, populated by DocumentRetrievalNode */
    inputs: Record<string, string>;

    /** The path to the directory from which to load input files */
    inputDirectoryPath: string;

    /** Conversation history between user and agent during analysis */
    analysisHistory: Array<{ role: Role; content: string }>;

    /** The final analysis output generated by the analysis agent */
    analysisOutput: string;

    /** The current question being asked by the agent during an analysis interrupt */
    currentAnalysisQuery: string;

    /** The name/ID of the LLM model to use for agent interactions */
    modelName: string;

    // New fields for Context Building Flow
    currentFlow?: Flow | null;
    systemName?: string;
    contextBuilderOutputContent?: string;
    contextBuilderOutputFileName?: string;

    // New field for system context - store just the state data
    system_context?: MemoryState | null;
}

function shouldTriggerAnalysis(state: AppState): boolean {
    return state.currentFlow === ANALYZE_FLOW;
}

function shouldTriggerContextBuilding(state: AppState): boolean {
    return state.currentFlow === BUILD_CONTEXT_FLOW;
}

// Update the StateGraphNode type to match RunnableLike
type StateGraphNode = Runnable<AppState, Partial<AppState>, RunnableConfig>;

// Define the channels for the graph state, specifying how they should be updated.
const channels = {
    userInput: { value: (x: string, y: string) => y ?? x, default: () => "" },
    inputDirectoryPath: { value: (x: string, y: string) => y ?? x, default: () => "" },
    inputs: { value: (x: Record<string, string>, y: Record<string, string>) => y ?? x, default: () => ({}) },
    response: { value: (x: string, y: string) => y ?? x, default: () => "" },
    fileContents: { value: (x: Record<string, string>, y: Record<string, string>) => y ?? x, default: () => ({}) },
    analysisHistory: { value: (x: Array<{ role: Role; content: string }>, y: Array<{ role: Role; content: string }>) => (x || []).concat(y || []), default: () => [] as Array<{ role: Role; content: string }> },
    analysisOutput: { value: (x: string, y: string) => y ?? x, default: () => "" },
    currentAnalysisQuery: { value: (x: string, y: string) => y ?? x, default: () => "" },
    modelName: { value: (x: string, y: string) => y ?? x, default: () => "" },

    // New channel configurations
    currentFlow: { value: (x: Flow | null | undefined, y: Flow | null | undefined) => y !== undefined ? y : x, default: () => null },
    systemName: { value: (x: string | undefined, y: string | undefined) => y !== undefined ? y : x, default: () => undefined },
    contextBuilderOutputContent: { value: (x: string | undefined, y: string | undefined) => y !== undefined ? y : x, default: () => undefined },
    contextBuilderOutputFileName: { value: (x: string | undefined, y: string | undefined) => y !== undefined ? y : x, default: () => undefined },
    system_context: { value: (x: MemoryState | null | undefined, y: MemoryState | null | undefined) => y ?? x, default: () => null },
};

export function safeAppConfig(config: RunnableConfig): AppRunnableConfig {
    if (!config.configurable) {
        throw new Error("configurable property is required");
    }
    return config as AppRunnableConfig;
}

/**
 * Creates and configures the application's state graph.
 * 
 * This function defines the nodes of the graph and the conditional edges that
 * determine the flow of execution based on the current `AppState`.
 * 
 * The graph handles different flows.
 * 
 * @param {Record<string, StateGraphNode>} nodes - A map where keys are node names (e.g., `ECHO_AGENT`) 
 *                                                and values are the corresponding node functions 
 *                                                (of type `StateGraphNode`).
 * @returns {StateGraph<AppState>} A configured `StateGraph` instance representing the application workflow.
 */
export function createWorkflow(nodes: Record<string, StateGraphNode>)
{
       return new StateGraph<AppState>({ channels })
        .addNode(ECHO_AGENT, nodes[ECHO_AGENT])
        .addNode(ANALYSIS_PREPARE, nodes[ANALYSIS_PREPARE])
        .addNode(ANALYSIS_INTERRUPT, nodes[ANALYSIS_INTERRUPT])
        .addNode(DOCUMENT_RETRIEVAL, nodes[DOCUMENT_RETRIEVAL])
        .addNode(CONTEXT_BUILDING_AGENT, nodes[CONTEXT_BUILDING_AGENT])
        
        // Define the entry point and initial routing logic from START
        .addConditionalEdges(START, 
            (state: AppState) => { // This decision function must be synchronous
                
                const userInput = state.userInput.toLowerCase();
                let nextNodeDecision: string;

                if (shouldTriggerAnalysis(state)) {
                    // For analysis flow, first retrieve documents
                    nextNodeDecision = DOCUMENT_RETRIEVAL;
                }
                else if (shouldTriggerContextBuilding(state)) {
                    // For context building flow, first retrieve documents
                    nextNodeDecision = DOCUMENT_RETRIEVAL;
                } else if (userInput.startsWith(CMD_ECHO)) {
                    // If the input is an echo command, route to the echo agent
                    nextNodeDecision = ECHO_AGENT;
                } else {
                    // If no specific flow or command is identified, end the process
                    nextNodeDecision = END;
                }
                
                dbg(`Initial Routing from START: Routing to ${nextNodeDecision}`);
                return nextNodeDecision;
            },
            {
                // Mapping of decision outcomes to actual node names
                [ECHO_AGENT]: ECHO_AGENT,
                [DOCUMENT_RETRIEVAL]: DOCUMENT_RETRIEVAL,
                [END]: END,
            }
        )
        // Define routing after the DOCUMENT_RETRIEVAL node completes
        .addConditionalEdges(DOCUMENT_RETRIEVAL, 
            (state: AppState) => {
                switch (state.currentFlow) {
                    case ANALYZE_FLOW:
                        dbg('Routing after Document Retrieval to Analysis Prepare');
                        return ANALYSIS_PREPARE; // Proceed to analysis preparation
                    case BUILD_CONTEXT_FLOW:
                        dbg('Routing after Document Retrieval to Context Building Agent');
                        return CONTEXT_BUILDING_AGENT; // Proceed to context building
                    default:
                        // Fallback if the flow is unknown or not set
                        console.warn("Unknown flow in routeAfterDocumentRetrieval:", state.currentFlow);
                        dbg('Routing after Document Retrieval to END due to unknown flow.');
                        return END; 
                }
            },
            {
                [ANALYSIS_PREPARE]: ANALYSIS_PREPARE,
                [CONTEXT_BUILDING_AGENT]: CONTEXT_BUILDING_AGENT,
                [END]: END
            }
        )
        // Define terminal edges for specific flows
        .addEdge(CONTEXT_BUILDING_AGENT, END) // Context building flow ends after the agent
        .addEdge(ECHO_AGENT, END)             // Echo flow ends after the agent
        
        // Define routing for the analysis preparation step
        .addConditionalEdges(ANALYSIS_PREPARE,
            (state: AppState) => { // This decision function must be synchronous 
                if (state.analysisOutput) {
                    // If final analysis output is generated, end the flow
                    return END;
                } else {
                    // Otherwise, proceed to the interrupt node to await user input/confirmation
                    return ANALYSIS_INTERRUPT;
                }
            },
            {
                [END]: END,
                [ANALYSIS_INTERRUPT]: ANALYSIS_INTERRUPT
            }
        )
        // After the ANALYSIS_INTERRUPT node (e.g., user provides more input), 
        // loop back to ANALYSIS_PREPARE to process the new state.
        .addEdge(ANALYSIS_INTERRUPT, ANALYSIS_PREPARE) 
    ;
}

const nodes = {
    [ECHO_AGENT]: echoAgentNode as unknown as StateGraphNode,
    [ANALYSIS_PREPARE]: analysisPrepareNode as unknown as StateGraphNode,
    [ANALYSIS_INTERRUPT]: analysisInterruptNode as unknown as StateGraphNode,
    [DOCUMENT_RETRIEVAL]: documentRetrievalNode as unknown as StateGraphNode,
    [CONTEXT_BUILDING_AGENT]: contextBuildingAgentNode as unknown as StateGraphNode,
}
const workflow = createWorkflow(nodes);
const checkpointer = new MemorySaver();
export const app = workflow.compile({ checkpointer }); 