import { StateGraph, END, START, MemorySaver } from "@langchain/langgraph";
import { echoAgentNode } from "./EchoAgentNode";
import { analysisPrepareNode } from "./AnalysisPrepareNode";
import { analysisInterruptNode } from "./AnalysisInterruptNode";
import { documentRetrievalNode } from "./DocumentRetrievalNode";
import { contextBuildingAgentNode } from './ContextBuildingAgentNode';
import { dbg } from "../utils";

// Define node names as constants
const ECHO_AGENT = "echoAgent";
const ANALYSIS_PREPARE = "analysisPrepare";
const ANALYSIS_INTERRUPT = "analysisInterrupt";
const DOCUMENT_RETRIEVAL = "documentRetrievalNode";
const CONTEXT_BUILDING_AGENT = "contextBuildingAgent";

/**
 * Represents the role of a participant in a conversation.
 * - 'user': Represents messages/inputs from the human user
 * - 'agent': Represents responses from the AI agent
 */
export type Role = 'user' | 'agent';

export const ANALYZE_FLOW = 'analyze';
export const BUILD_CONTEXT_FLOW = 'build_context';
export type Flow = typeof ANALYZE_FLOW | typeof BUILD_CONTEXT_FLOW; 

const CMD_ECHO = "echo";

/**
 * Represents the core application state that flows through the agent graph.
 * This state is passed between nodes and updated during graph execution.
 */
export interface AppState {
    /** The raw input text provided by the user */
    userInput: string;

    /** The latest response generated by an agent node */
    response: string;

    /** Map of file paths to their contents for code analysis */
    fileContents: Record<string, string>;

    /** Map of input file names to their contents, populated by DocumentRetrievalNode */
    inputs: Record<string, string>;

    /** The path to the directory from which to load input files */
    inputDirectoryPath: string;

    /** Conversation history between user and agent during analysis */
    analysisHistory: Array<{ role: Role; content: string }>;

    /** The final analysis output generated by the analysis agent */
    analysisOutput: string;

    /** The current question being asked by the agent during an analysis interrupt */
    currentAnalysisQuery: string;

    /** The name/ID of the LLM model to use for agent interactions */
    modelName: string;

    // New fields for Context Building Flow
    currentFlow?: Flow | null;
    systemName?: string;
    contextBuilderOutputContent?: string;
    contextBuilderOutputFileName?: string;
}

function shouldTriggerAnalysis(state: AppState): boolean {
    return state.currentFlow === ANALYZE_FLOW;
}

function shouldTriggerContextBuilding(state: AppState): boolean {
    return state.currentFlow === BUILD_CONTEXT_FLOW;
}

// Define the channels for the graph state, specifying how they should be updated.
const channels = {
    userInput: { value: (x: string, y: string) => y ?? x, default: () => "" },
    inputDirectoryPath: { value: (x: string, y: string) => y ?? x, default: () => "" },
    inputs: { value: (x: Record<string, string>, y: Record<string, string>) => y ?? x, default: () => ({}) },
    response: { value: (x: string, y: string) => y ?? x, default: () => "" },
    fileContents: { value: (x: Record<string, string>, y: Record<string, string>) => y ?? x, default: () => ({}) },
    analysisHistory: { value: (x: Array<{ role: Role; content: string }>, y: Array<{ role: Role; content: string }>) => (x || []).concat(y || []), default: () => [] as Array<{ role: Role; content: string }> },
    analysisOutput: { value: (x: string, y: string) => y ?? x, default: () => "" },
    currentAnalysisQuery: { value: (x: string, y: string) => y ?? x, default: () => "" },
    modelName: { value: (x: string, y: string) => y ?? x, default: () => "" },

    // New channel configurations
    currentFlow: { value: (x: Flow | null | undefined, y: Flow | null | undefined) => y !== undefined ? y : x, default: () => null },
    systemName: { value: (x: string | undefined, y: string | undefined) => y !== undefined ? y : x, default: () => undefined },
    contextBuilderOutputContent: { value: (x: string | undefined, y: string | undefined) => y !== undefined ? y : x, default: () => undefined },
    contextBuilderOutputFileName: { value: (x: string | undefined, y: string | undefined) => y !== undefined ? y : x, default: () => undefined },
};

// Instantiate the graph with the defined state and channels.
const workflow = new StateGraph<AppState>({ channels })
    .addNode(ECHO_AGENT, echoAgentNode)
    .addNode(ANALYSIS_PREPARE, analysisPrepareNode)
    .addNode(ANALYSIS_INTERRUPT, analysisInterruptNode)
    .addNode(DOCUMENT_RETRIEVAL, documentRetrievalNode)
    .addNode(CONTEXT_BUILDING_AGENT, contextBuildingAgentNode)
    
    // Make the conditional edge originate from START
    .addConditionalEdges(START, 
        (state: AppState) => { // Keep synchronous
            
            const userInput = state.userInput.toLowerCase();
            let nextNodeDecision: string;

            if (shouldTriggerAnalysis(state)) {
                nextNodeDecision = DOCUMENT_RETRIEVAL;
            }
            else if (shouldTriggerContextBuilding(state)) {
                nextNodeDecision = DOCUMENT_RETRIEVAL;
            } else if (userInput.startsWith(CMD_ECHO)) {
                nextNodeDecision = ECHO_AGENT;
            } else {
                nextNodeDecision = END;
            }
            
            dbg(`Initial Routing from START: Routing to ${nextNodeDecision}`);
            return nextNodeDecision;
        },
        {
            // Mapping destinations
            [ECHO_AGENT]: ECHO_AGENT,
            [DOCUMENT_RETRIEVAL]: DOCUMENT_RETRIEVAL,
            [END]: END,
        }
    )
    .addConditionalEdges(DOCUMENT_RETRIEVAL, 
        (state: AppState) => {
            switch (state.currentFlow) {
                case ANALYZE_FLOW:
                    dbg('Routing after Document Retrieval to Analysis Prepare');
                    return ANALYSIS_PREPARE;
                case BUILD_CONTEXT_FLOW:
                    dbg('Routing after Document Retrieval to Context Building Agent');
                    return CONTEXT_BUILDING_AGENT;
                default:
                    console.warn("Unknown flow in routeAfterDocumentRetrieval:", state.currentFlow);
                    dbg('Routing after Document Retrieval to END due to unknown flow.');
                    return END; // Default to END if flow is not set or unknown
            }
        },
        {
            [ANALYSIS_PREPARE]: ANALYSIS_PREPARE,
            [CONTEXT_BUILDING_AGENT]: CONTEXT_BUILDING_AGENT,
            [END]: END
        }
    )
    .addEdge(CONTEXT_BUILDING_AGENT, END)
    .addEdge(ECHO_AGENT, END)
    .addConditionalEdges(ANALYSIS_PREPARE,
        (state: AppState) => { // Keep synchronous 
            if (state.analysisOutput) {
                return END;
            } else {
                return ANALYSIS_INTERRUPT;
            }
        },
        {
            [END]: END,
            [ANALYSIS_INTERRUPT]: ANALYSIS_INTERRUPT
        }
    )
    .addEdge(ANALYSIS_INTERRUPT, ANALYSIS_PREPARE) // After interrupt node, go back to the PREPARE node to process the resumed input
;

const checkpointer = new MemorySaver();
export const app = workflow.compile({ checkpointer }); 