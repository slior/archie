# Agent Graph Documentation

This document describes the structure and flow of the primary agent graph defined in `src/agents/graph.ts`.

## Visual Diagram

The following diagram represents the nodes and edges of the compiled agent graph. The initial routing logic occurs in the conditional edge after the START node and after the documentRetrievalNode.

<!-- MERMAID_DIAGRAM_START -->
```mermaid
graph TD;
    START([Start]);
    documentRetrievalNode([documentRetrievalNode]);
    analysisPrepare([analysisPrepare]);
    analysisInterrupt([analysisInterrupt]);
    contextBuildingAgent([contextBuildingAgent]);
    echoAgent([echoAgent]);
    END([End]);

    START -- "analyze:" or "build_context:" --> documentRetrievalNode;
    START -- "echo" keyword --> echoAgent;
    START -- other --> END;

    documentRetrievalNode -- currentFlow is 'analyze' --> analysisPrepare;
    documentRetrievalNode -- currentFlow is 'build_context' --> contextBuildingAgent;
    documentRetrievalNode -- currentFlow is null/invalid --> END; 

    analysisPrepare -- has analysisOutput --> END;
    analysisPrepare -- no analysisOutput --> analysisInterrupt;
    analysisInterrupt --> analysisPrepare;
    contextBuildingAgent --> END;
    echoAgent --> END;
```
<!-- MERMAID_DIAGRAM_END -->

## State (`AppState`)

The graph operates on a state object defined by the `AppState` interface.

*   `userInput`: The input provided by the user, used for initial routing and processed by agents.
*   `response`: Stores the latest response from the `echoAgent`.
*   `fileContents`: Holds the content of files relevant to the analysis task. (Note: This may be deprecated in the future in favor of `inputs`).
*   `inputs`: Holds a mapping of input file names (basenames) to their string content, populated by the `documentRetrievalNode`.
*   `inputDirectoryPath`: Stores the path to the directory from which input files should be read by `documentRetrievalNode`.
*   `analysisHistory`: Tracks the conversation turns between the user and the analysis agent.
*   `analysisOutput`: Stores the final output generated by the analysis agent upon approval.
*   `currentAnalysisQuery`: Holds the question posed by the analysis agent during an interrupt.
*   `currentFlow`: Indicates the current operational flow, either `'analyze'` or `'build_context'`, guiding conditional routing.
*   `systemName`: The name of the system or feature for the `build_context` flow.
*   `contextBuilderOutputContent`: Stores the generated content from the `contextBuildingAgentNode`.
*   `contextBuilderOutputFileName`: Stores the target filename for the context overview.

## Nodes

The graph consists of the following nodes:

*   **`START`**: The special entry point node.
*   **`documentRetrievalNode`**: Reads input files (`.txt`, `.md`) from the directory specified in `AppState.inputDirectoryPath` and populates `AppState.inputs` with their content (filename: content). Warns and skips unreadable files.
*   **`echoAgent`**: Simple agent for echoing input.
*   **`analysisPrepare`**: Handles analysis logic, LLM calls, state updates, and checks for completion for the 'analyze' flow. Reads inputs from `AppState.inputs`.
*   **`analysisInterrupt`**: Triggers the pause (`interrupt`) to wait for user input during analysis.
*   **`contextBuildingAgent`**: Generates a system context overview using an LLM based on `AppState.inputs` and `AppState.systemName` for the 'build_context' flow. Populates `AppState.contextBuilderOutputContent` and `AppState.contextBuilderOutputFileName`.
*   **`END`**: The special exit point node.

## Flow / Edges

The execution flow follows these connections:

1.  **`START` -> Conditional Routing**: The graph evaluates the initial `userInput`:
    *   If `userInput` starts with "analyze:" or "build_context:" -> `documentRetrievalNode`.
    *   If `userInput` starts with "echo" -> `echoAgent`.
    *   Otherwise -> `END`.
2.  **`documentRetrievalNode` -> Conditional Routing**: After `documentRetrievalNode` retrieves input files (populating `AppState.inputs`), it transitions based on `AppState.currentFlow`:
    *   If `currentFlow` is `'analyze'` -> `analysisPrepare`.
    *   If `currentFlow` is `'build_context'` -> `contextBuildingAgent`.
    *   If `currentFlow` is not set or invalid, it may route to `END` (or handle as an error, depending on implementation).
3.  **`analysisPrepare` -> `analysisInterrupt` (Conditional)**: If `analysisPrepare` completes *without* generating a final `analysisOutput`, it transitions to `analysisInterrupt`.
4.  **`analysisPrepare` -> `END` (Conditional)**: If `analysisPrepare` completes *with* a final `analysisOutput` (e.g., solution approved or an error like missing inputs occurred), the graph terminates.
5.  **`analysisInterrupt` -> `analysisPrepare`**: After resuming from an interrupt, execution always returns to `analysisPrepare` to process the user's input.
6.  **`contextBuildingAgent` -> `END`**: After `contextBuildingAgent` generates the context overview content and filename, the graph terminates. (The actual file persistence happens in the `build-context` command handler after the graph concludes).
7.  **`echoAgent` -> `END`**: After the `echoAgent` completes, the graph always terminates. 